<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>AED ã·ã‚ˆã·ã‚ˆ</title>
<style>
/* --- ç”»é¢å…¨ä½“ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆã®ä¿®æ­£ (Flexboxã§ç”»é¢ä¸­å¤®ã«é…ç½®) --- */
html, body {
    /* height: 100vh; ã§ã¯ãªã 100% ã‚’ä½¿ç”¨ã—ã€ãƒ–ãƒ©ã‚¦ã‚¶ã®ãƒ„ãƒ¼ãƒ«ãƒãƒ¼ã«ã‚ˆã‚‹å¤‰å‹•ã«æŸ”è»Ÿã«å¯¾å¿œ */
    height: 100%; 
    margin: 0;
    /* padding: 0; ã‚’ä½¿ç”¨ã—ã€æ¨ªå‘ãæ™‚ã®ä½™ç™½ã‚’ç¢ºä¿ã—ãªã„ */
    padding: 0;
    overflow: hidden; /* ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«é˜²æ­¢ */
}

body {
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    font-family: Arial, sans-serif;
    color: white;
    -webkit-tap-highlight-color: transparent; 
    box-sizing: border-box;
    
    /* bodyã‚’Flexboxã«ã—ã€ã‚³ãƒ³ãƒ†ãƒ³ãƒ„å…¨ä½“ã‚’ä¸­å¤®ã«é…ç½® */
    display: flex;
    justify-content: center;
    align-items: center;
    /* max-heightã‚’å‰Šé™¤ã—ã€æ¨ªå‘ãæ™‚ã«é ˜åŸŸãŒå›ºå®šã•ã‚Œãªã„ã‚ˆã†ã«ã™ã‚‹ */
}

#game-wrapper {
    /* ã‚²ãƒ¼ãƒ å…¨ä½“ã‚’å›²ã‚€ã‚³ãƒ³ãƒ†ãƒŠã€‚ç”»é¢ã‚µã‚¤ã‚ºã«å¿œã˜ã¦æŸ”è»Ÿã«ç¸®å°ãƒ»æ‹¡å¤§ */
    display: flex;
    flex-direction: column; 
    align-items: center;
    max-width: 100%; 
    max-height: 100%; /* bodyã®é«˜ã•å†…ã§åã¾ã‚‹ã‚ˆã†ã« */
    width: auto;
    box-sizing: border-box;
}

#game-title {
    font-size: 2rem;
    text-shadow: 3px 3px 6px rgba(0,0,0,0.7);
    margin: 10px 0 0 0; /* ã‚¹ã‚³ã‚¢ã®ä¸‹ã«ãã‚‹ã®ã§ä¸Šãƒãƒ¼ã‚¸ãƒ³ */
    flex-shrink: 0; 
}

#main-content {
    /* ã‚¹ãƒ†ãƒ¼ã‚¸ã‚¨ãƒªã‚¢ã¨NEXTã‚¨ãƒªã‚¢ã‚’æ¨ªã«ä¸¦ã¹ã‚‹ */
    display: flex;
    flex-direction: row;
    align-items: flex-start;
    flex-grow: 1; /* æ®‹ã‚Šã®é«˜ã•ã‚’æœ€å¤§é™ä½¿ç”¨ */
    width: 100%;
    min-height: 0; 
}

#game-container {
    /* ã‚¹ã‚³ã‚¢ã€ã‚¹ãƒ†ãƒ¼ã‚¸ã€ã‚¿ã‚¤ãƒˆãƒ«ã‚’å‚ç›´ã«ä¸¦ã¹ã‚‹ */
    display: flex;
    flex-direction: column;
    align-items: center;
    flex-grow: 1;
    min-height: 0;
}

#stage {
    position: relative;
    background: #1a1a2e;
    border: 4px solid #f5576c;
    border-radius: 10px;
    box-shadow: 0 0 30px rgba(245,87,108,0.5);
    touch-action: none; 
    flex-grow: 1; /* æ®‹ã‚Šã®é«˜ã•ã‚’ä½¿ã„ã€ã·ã‚ˆã‚µã‚¤ã‚ºè¨ˆç®—ã®åŸºæº–ã¨ã™ã‚‹ */
    margin: 0;
    /* overflow: hidden; ã‚’è¿½åŠ ã—ã€ã·ã‚ˆãŒã¯ã¿å‡ºãªã„ã‚ˆã†ã«ã™ã‚‹ */
    overflow: hidden;
}

#score {
    background: rgba(0,0,0,0.8);
    padding: 10px 15px;
    font-size: 1.2rem;
    font-weight: bold;
    border-radius: 8px;
    margin-bottom: 10px; 
    flex-shrink: 0; 
}

/* --- ã‚¹ã‚¿ãƒ¼ãƒˆç”»é¢ã®ä¿®æ­£ --- */
#start-screen {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.9);
    z-index: 100;
    display: flex;
    flex-direction: column;
    justify-content: space-around; 
    align-items: center;
    border-radius: 10px;
    box-sizing: border-box;
    padding: 10px;
    margin: 0; 
}
#start-screen h2 {
    font-size: 1.6rem;
    color: #f5576c;
    margin-bottom: 5px;
    margin-top: 5px;
}
#start-screen p {
    font-size: 0.9rem;
    line-height: 1.4;
    margin: 3px 0;
}
#start-button {
    padding: 10px 20px;
    font-size: 1.2rem;
    cursor: pointer;
    background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
    color: white;
    border: none;
    border-radius: 8px;
    margin-top: 15px;
    margin-bottom: 15px;
    box-shadow: 0 4px 15px rgba(245,87,108,0.5);
    transition: all 0.3s;
}

/* --- NEXT ã·ã‚ˆè¡¨ç¤ºã‚¨ãƒªã‚¢ã®ã‚¹ã‚¿ã‚¤ãƒ« --- */
#next-container {
    margin-left: 10px;
    text-align: left;
    display: flex;
    flex-direction: column;
    align-items: flex-start;
    flex-shrink: 0; 
}
#next-container h2 {
    font-size: 1.5rem;
    margin-top: 0;
    margin-bottom: 5px;
}
#next-puyo-container {
    position: relative;
    border: 2px solid #fff;
    border-radius: 5px;
    background: rgba(0,0,0,0.5);
    margin-top: 0;
}
#next-puyo-container canvas {
    position: absolute;
}
</style>
</head>
<body>
<div id="game-wrapper">
    
<div id="main-content">
        <div id="game-container">
            
<div id="score">ã‚¹ã‚³ã‚¢: <span id="score-value">0</span></div>
            <div id="stage">
                <div id="start-screen">
                    <h2>AED ã·ã‚ˆã·ã‚ˆã¸ã‚ˆã†ã“ãï¼</h2>
                    <p>åŒã˜è‰²ã®AEDã‚’<span style="color:#ffd700; font-weight: bold;">4ã¤ä»¥ä¸Š</span>æƒãˆã¦æ¶ˆãã†ï¼</p>
                    <p style="margin-top: 10px; font-size: 1.1rem;"><strong>æ“ä½œæ–¹æ³• (PC)</strong></p>
                    <p><strong>ç§»å‹•:</strong> â† â†’</p>
                    <p><strong>å›è»¢:</strong> â†‘ (ã¾ãŸã¯ Z ã‚­ãƒ¼)</p>
                    <p><strong>é«˜é€Ÿè½ä¸‹:</strong> â†“</p>
                    <p style="margin-top: 10px; font-size: 1.1rem;"><strong>æ“ä½œæ–¹æ³• (ã‚¹ãƒãƒ›)</strong></p>
                    <p><strong>ç§»å‹•:</strong> å·¦å³ã‚¹ãƒ©ã‚¤ãƒ‰</p>
                    <p><strong>å›è»¢:</strong> ç”»é¢ã‚¿ãƒƒãƒ—</p>
                    <p><strong>é«˜é€Ÿè½ä¸‹:</strong> ä¸‹ã‚¹ãƒ©ã‚¤ãƒ‰</p>
                    <button id="start-button">ã‚²ãƒ¼ãƒ ã‚¹ã‚¿ãƒ¼ãƒˆ</button>
                </div>
                
                <div id="combo-display"></div>
            </div>
            
<h1 id="game-title">ğŸ¥ AED ã·ã‚ˆã·ã‚ˆ ğŸ¥</h1>
        </div>

        <div id="next-container">
            <h2>NEXT</h2>
            <div id="next-puyo-container">
                </div>
        </div>
    </div>
</div>

<script>
class Config {
    static puyoSize = 0;
    static cols = 6;
    static rows = 12;
    // è½ä¸‹é€Ÿåº¦ã¯puyoSizeã«å¿œã˜ã¦èª¿æ•´ã•ã‚Œã‚‹ãŸã‚ã€ã“ã“ã§ã¯ã€Œé€Ÿã•ã®å€ç‡ã€ã¨ã—ã¦å®šç¾©
    static freeFallingSpeedRatio = 0.5; // è‡ªç”±è½ä¸‹ã®é€Ÿã•ï¼ˆãƒã‚¹ã®ç§»å‹•é‡ï¼‰
    static playerFallingSpeedRatio = 0.03; // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼æ“ä½œä¸­ã®è½ä¸‹é€Ÿåº¦ï¼ˆãƒã‚¹ã®ç§»å‹•é‡ï¼‰
    static playerDownSpeedRatio = 0.3; // é«˜é€Ÿè½ä¸‹æ™‚ã®è¿½åŠ é€Ÿåº¦ï¼ˆãƒã‚¹ã®ç§»å‹•é‡ï¼‰

    static erasePuyoCount = 4;
    static eraseAnimationDuration = 30;
    static playerGroundFrame = 20;
    static comboDisplayDuration = 60;
    static touchThreshold = 50;
    static moveInterval = 5;
}

const AED_TYPES = ['red', 'blue', 'white', 'yellow', 'green'];

function drawAED(ctx, type, size) {
    const isSquare = ['red', 'blue', 'green'].includes(type);
    const colors = {
        red: '#ff0000',
        blue: '#3399ff',
        white: '#f0f0f0',
        yellow: '#ffd700',
        green: '#22c55e'
    };
    
    ctx.save();
    ctx.clearRect(0, 0, size, size);
    
    // ã·ã‚ˆã®æç”»
    if (isSquare) {
        ctx.fillStyle = colors[type];
        ctx.fillRect(size * 0.1, size * 0.1, size * 0.8, size * 0.8);
        ctx.strokeStyle = type === 'red' ? '#cc0000' : type === 'blue' ? '#0066cc' : '#16a34a';
        ctx.lineWidth = size * 0.06;
        ctx.strokeRect(size * 0.1, size * 0.1, size * 0.8, size * 0.8);
    } else {
        ctx.beginPath();
        ctx.arc(size/2, size/2, size * 0.4, 0, Math.PI*2);
        ctx.fillStyle = colors[type];
        ctx.fill();
        ctx.strokeStyle = type === 'white' ? '#ccc' : '#daa520';
        ctx.lineWidth = size * 0.06;
        ctx.stroke();
    }
    
    // æ–‡å­—ã®æç”»
    ctx.fillStyle = isSquare ? 'white' : '#333';
    ctx.font = `bold ${Math.max(10, size * 0.28)}px Arial`;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText('AED', size/2, size/2);
    ctx.restore();
}

class Stage {
    constructor() {
        this.element = document.getElementById('stage');
        this.board = Array(Config.rows).fill().map(() => Array(Config.cols).fill(null));
        this.puyoCount = 0;
        this.fallingPuyoList = [];
        this.erasingPuyoInfoList = [];
        this.eraseStartFrame = 0;
    }
    
    setSize(puyoSize) {
        this.element.style.width = puyoSize * Config.cols + 'px';
        this.element.style.height = puyoSize * Config.rows + 'px';
        
        document.getElementById('start-screen').style.width = puyoSize * Config.cols + 'px';
        document.getElementById('start-screen').style.height = puyoSize * Config.rows + 'px';
    }

    setPuyo(x, y, type) {
        const size = Config.puyoSize;
        const canvas = document.createElement('canvas');
        canvas.width = size;
        canvas.height = size;
        canvas.style.position = 'absolute';
        canvas.style.left = x * size + 'px';
        canvas.style.top = y * size + 'px';
        
        const ctx = canvas.getContext('2d');
        drawAED(ctx, type, size);
        
        this.element.appendChild(canvas);
        this.board[y][x] = { type, element: canvas };
    }
    
    checkFall() {
        this.fallingPuyoList = [];
        let isFalling = false;
        
        for (let y = Config.rows - 2; y >= 0; y--) {
            for (let x = 0; x < Config.cols; x++) {
                if (!this.board[y][x]) continue;
                if (this.board[y + 1][x]) continue;
                
                let cell = this.board[y][x];
                this.board[y][x] = null;
                
                let dst = y;
                while (dst + 1 < Config.rows && !this.board[dst + 1][x]) {
                    dst++;
                }
                
                this.board[dst][x] = cell;
                this.fallingPuyoList.push({
                    element: cell.element,
                    position: y * Config.puyoSize,
                    destination: dst * Config.puyoSize,
                    falling: true
                });
                isFalling = true;
            }
        }
        return isFalling;
    }
    
    fall() {
        let isFalling = false;
        // è½ä¸‹é€Ÿåº¦ã‚’puyoSizeã«æ¯”ä¾‹ã•ã›ã€ã™ã‚ŠæŠœã‘ã‚’é˜²ã
        const fallSpeed = Config.puyoSize * Config.freeFallingSpeedRatio;

        for (const puyo of this.fallingPuyoList) {
            if (!puyo.falling) continue;
            
            puyo.position += fallSpeed;
            if (puyo.position >= puyo.destination) {
                puyo.position = puyo.destination;
                puyo.falling = false;
            } else {
                isFalling = true;
            }
            puyo.element.style.top = puyo.position + 'px';
        }
        return isFalling;
    }
    
    checkErase(frame) {
        this.eraseStartFrame = frame;
        this.erasingPuyoInfoList = [];
        const erasedPuyoColor = {};
        
        const sequencePuyoInfoList = [];
        const existingPuyoInfoList = [];
        
        const checkSequentialPuyo = (x, y) => {
            const orig = this.board[y][x];
            if (!orig) return;
            
            const type = this.board[y][x].type;
            sequencePuyoInfoList.push({ x, y, cell: this.board[y][x] });
            this.board[y][x] = null;
            
            const directions = [[0,1], [1,0], [0,-1], [-1,0]];
            for (const [dx, dy] of directions) {
                const nx = x + dx;
                const ny = y + dy;
                if (nx < 0 || ny < 0 || nx >= Config.cols || ny >= Config.rows) continue;
                const cell = this.board[ny][nx];
                if (!cell || cell.type !== type) continue;
                checkSequentialPuyo(nx, ny);
            }
        };
        
        for (let y = 0; y < Config.rows; y++) {
            for (let x = 0; x < Config.cols; x++) {
                sequencePuyoInfoList.length = 0;
                const puyoType = this.board[y][x]?.type;
                if (!puyoType) continue;
                
                checkSequentialPuyo(x, y);
                
                if (sequencePuyoInfoList.length >= Config.erasePuyoCount) {
                    this.erasingPuyoInfoList.push(...sequencePuyoInfoList);
                    erasedPuyoColor[puyoType] = true;
                } else if (sequencePuyoInfoList.length > 0) {
                    existingPuyoInfoList.push(...sequencePuyoInfoList);
                }
            }
        }
        
        this.puyoCount -= this.erasingPuyoInfoList.length;
        
        for (const info of existingPuyoInfoList) {
            this.board[info.y][info.x] = info.cell;
        }
        
        if (this.erasingPuyoInfoList.length) {
            return {
                piece: this.erasingPuyoInfoList.length,
                color: Object.keys(erasedPuyoColor).length
            };
        }
        return null;
    }
    
    erasing(frame) {
        const ratio = (frame - this.eraseStartFrame) / Config.eraseAnimationDuration;
        if (ratio > 1) {
            for (const info of this.erasingPuyoInfoList) {
                this.element.removeChild(info.cell.element);
            }
            return false;
        }
        
        const visible = Math.floor(ratio * 4) % 2 === 0;
        for (const info of this.erasingPuyoInfoList) {
            info.cell.element.style.display = visible ? 'block' : 'none';
        }
        return true;
    }
}

class Player {
    constructor(stage) {
        this.stage = stage;
        this.keyStatus = { left: false, right: false, up: false, down: false, rotate: false };
        this.moveFrame = 0;
        this.setupControls();
        
        this.centerPuyo = null;
        this.movablePuyo = null;
        this.centerElement = null;
        this.movableElement = null;
        this.puyoStatus = null;
        this.groundFrame = 0;
    }
    
    setupControls() {
        const setKey = (key, val) => {
            if (key === 37) this.keyStatus.left = val;
            else if (key === 38 || key === 90) this.keyStatus.rotate = val;
            else if (key === 39) this.keyStatus.right = val;
            else if (key === 40) this.keyStatus.down = val;
            
            if (!val) {
                if (key === 37 || key === 39) this.moveFrame = 0;
            }
        };
        
        document.addEventListener('keydown', e => {
            setKey(e.keyCode, true);
            if ([37,38,39,40,90].includes(e.keyCode)) e.preventDefault();
        });
        
        document.addEventListener('keyup', e => {
            setKey(e.keyCode, false);
        });
    }

    setTouchAction(action) {
        switch (action) {
            case 'left':
                this.keyStatus.left = true;
                this.keyStatus.right = false;
                break;
            case 'right':
                this.keyStatus.right = true;
                this.keyStatus.left = false;
                break;
            case 'down':
                this.keyStatus.down = true;
                break;
            case 'rotate':
                this.keyStatus.rotate = true;
                break;
            case 'release_horizontal':
                this.keyStatus.left = false;
                this.keyStatus.right = false;
                this.moveFrame = 0;
                break;
            case 'release_down':
                this.keyStatus.down = false;
                break;
        }
    }
    
    createNewPuyo(nextPuyoType) {
        if (this.stage.board[0][2]) return false;
        
        this.centerPuyo = nextPuyoType.center;
        this.movablePuyo = nextPuyoType.movable;
        const size = Config.puyoSize;
        
        this.centerElement = document.createElement('canvas');
        this.centerElement.width = size;
        this.centerElement.height = size;
        this.centerElement.style.position = 'absolute';
        const ctx1 = this.centerElement.getContext('2d');
        drawAED(ctx1, this.centerPuyo, size);
        
        this.movableElement = document.createElement('canvas');
        this.movableElement.width = size;
        this.movableElement.height = size;
        this.movableElement.style.position = 'absolute';
        const ctx2 = this.movableElement.getContext('2d');
        drawAED(ctx2, this.movablePuyo, size);
        
        this.stage.element.appendChild(this.centerElement);
        this.stage.element.appendChild(this.movableElement);
        
        this.puyoStatus = {
            x: 2,
            y: -1,
            // 90åº¦å›è»¢ï¼ˆå³ï¼‰ã®çŠ¶æ…‹ã‚’åˆæœŸå€¤ã«è¨­å®š (dx=1, dy=0)
            dx: 1, 
            dy: 0,
            rotation: 90
        };
        
        this.groundFrame = 0;
        this.setPuyoPosition();
        return true;
    }
    
    setPuyoPosition() {
        const size = Config.puyoSize;
        const left = this.puyoStatus.x * size;
        const top = this.puyoStatus.y * size;
        
        this.centerElement.style.left = left + 'px';
        this.centerElement.style.top = top + 'px';
        
        // movableã·ã‚ˆã¯ä¸­å¿ƒã·ã‚ˆã‹ã‚‰ã®ç›¸å¯¾åº§æ¨™ã§é…ç½®
        const mx = left + this.puyoStatus.dx * size;
        const my = top + this.puyoStatus.dy * size;
        
        this.movableElement.style.left = mx + 'px';
        this.movableElement.style.top = my + 'px';
    }
    
    canMove(cx) {
        // x, yã¯å°æ•°ç‚¹ã‚’å«ã‚€å¯èƒ½æ€§ãŒã‚ã‚‹ãŸã‚ã€å››æ¨äº”å…¥ã—ã¦æ•´æ•°ã‚»ãƒ«åº§æ¨™ã‚’æ±‚ã‚ã‚‹
        const x = Math.round(this.puyoStatus.x);
        const y = Math.floor(this.puyoStatus.y);
        const mx = x + this.puyoStatus.dx;
        const my = y + this.puyoStatus.dy;
        
        let can = true;
        
        // ä¸­å¿ƒã·ã‚ˆã®ãƒã‚§ãƒƒã‚¯
        const newX = x + cx;
        if (newX < 0 || newX >= Config.cols || (y >= 0 && this.stage.board[y]?.[newX])) {
            can = false;
        }
        
        // å¯å‹•ã·ã‚ˆã®ãƒã‚§ãƒƒã‚¯
        const newMx = mx + cx;
        if (can && (newMx < 0 || newMx >= Config.cols || (my >= 0 && this.stage.board[my]?.[newMx]))) {
            can = false;
        }
        return can;
    }

    movePuyo() {
        const isHorizontalKeyDown = this.keyStatus.left || this.keyStatus.right;
        
        if (!('ontouchstart' in window) && isHorizontalKeyDown) {
            const shouldMove = (this.moveFrame === 0) || (this.moveFrame > 15 && this.moveFrame % Config.moveInterval === 0);

            this.moveFrame++;
            
            if (shouldMove) {
                const cx = this.keyStatus.right ? 1 : -1;
                
                if (this.canMove(cx)) {
                    this.puyoStatus.x += cx;
                    if (this.groundFrame > 0) {
                        this.groundFrame = 0;
                    }
                }
            }
        } 
        else if (('ontouchstart' in window) && isHorizontalKeyDown) {
            // ã‚¹ãƒãƒ›ã§ã¯ã€ãƒœã‚¿ãƒ³ã§ã¯ãªãã‚¹ãƒ©ã‚¤ãƒ‰æ“ä½œã‚’æƒ³å®šã™ã‚‹ãŸã‚ã€
            // å·¦å³ã®ã‚­ãƒ¼æŠ¼ä¸‹ã¯çŸ­ã„æ™‚é–“ã§åˆ¤å®šã‚’è§£é™¤ã™ã‚‹ã€‚
            const cx = this.keyStatus.right ? 1 : -1;
            
            if (this.canMove(cx)) {
                this.puyoStatus.x += cx;
                if (this.groundFrame > 0) {
                    this.groundFrame = 0;
                }
            }
        }
        
        if (!isHorizontalKeyDown) {
            this.moveFrame = 0;
        }
    }
    
    falling(isDownPressed) {
        const x = Math.round(this.puyoStatus.x); // xã¯å››æ¨äº”å…¥ã§æ•´æ•°ã‚»ãƒ«åº§æ¨™ã‚’ä½¿ã†
        const y = Math.floor(this.puyoStatus.y);
        const dx = this.puyoStatus.dx;
        const dy = this.puyoStatus.dy;
        
        const checkBlocked = (cy) => {
            // ä¸­å¿ƒã·ã‚ˆã®ä¸‹ã®ã‚»ãƒ«ã‚’ãƒã‚§ãƒƒã‚¯
            if (cy + 1 >= Config.rows) return true;
            if (cy >= -1 && this.stage.board[cy + 1]?.[x]) return true; // cy=-1ã®ã¨ãã€y=0ã®ã‚»ãƒ«ã‚’ãƒã‚§ãƒƒã‚¯
            
            // å¯å‹•ã·ã‚ˆã®ä¸‹ã®ã‚»ãƒ«ã‚’ãƒã‚§ãƒƒã‚¯
            const mpy = cy + dy;
            const mpx = x + dx;
            
            if (mpy + 1 >= Config.rows) return true;
            if (mpy >= -1 && this.stage.board[mpy + 1]?.[mpx]) return true;
            
            return false;
        };
        
        const isBlocked = checkBlocked(y);
        
        if (!isBlocked) {
            // è½ä¸‹é€Ÿåº¦ã¯ puyoSize * å‰²åˆ (1ãƒ•ãƒ¬ãƒ¼ãƒ ã‚ãŸã‚Šæœ€å¤§1ãƒã‚¹)
            const speed = Config.puyoSize * (Config.playerFallingSpeedRatio + (isDownPressed ? Config.playerDownSpeedRatio : 0));
            
            this.puyoStatus.y += speed / Config.puyoSize;
            
            const newY = Math.floor(this.puyoStatus.y);
            
            // æ•´æ•°åº§æ¨™ã‚’è¶ŠãˆãŸã¨ãã«ã€ãƒ–ãƒ­ãƒƒã‚¯ã•ã‚Œã¦ã„ã‚‹ã‹ç¢ºèª
            if (newY > y) {
                if (checkBlocked(newY)) {
                    this.puyoStatus.y = newY; // æ•´æ•°åº§æ¨™ã«ä¿®æ­£
                    this.groundFrame = 1;
                } else {
                    this.groundFrame = 0;
                }
            }
            return false;
        }
        
        // æ¥åœ°åˆ¤å®š
        if (this.groundFrame === 0) {
            // æ—¢ã«ç€åœ°ã—ã¦ã„ã‚‹å ´åˆã€ç¾åœ¨ã®ä½ç½®ã‚’æœ€çµ‚çš„ãªã‚»ãƒ«ä½ç½®ã«å››æ¨äº”å…¥ã—ã¦å›ºå®š
            this.puyoStatus.y = y; 
            this.groundFrame = 1;
            return false;
        }
        
        this.groundFrame++;
        return this.groundFrame > Config.playerGroundFrame;
    }
    
    playing() {
        this.movePuyo();
        
        if (this.falling(this.keyStatus.down)) {
            this.setPuyoPosition();
            return 'fix';
        }
        
        if (this.keyStatus.rotate) {
            const currentRot = this.puyoStatus.rotation;
            const nextRot = (currentRot + 90) % 360;
            const x = Math.round(this.puyoStatus.x);
            const y = Math.floor(this.puyoStatus.y);
            
            // 90åº¦å›è»¢ã”ã¨ã® (dx, dy) ã®å¤‰åŒ–
            // 90åº¦: (1, 0), 180åº¦: (0, 1), 270åº¦: (-1, 0), 0åº¦: (0, -1)
            const dCombi = [[0, -1], [1, 0], [0, 1], [-1, 0]]; 
            
            const nextDx = dCombi[nextRot / 90][0];
            const nextDy = dCombi[nextRot / 90][1];
            
            let newX = x;
            let canRotate = true;
            
            const nextCx = x + nextDx; // æ–°ã—ã„å¯å‹•ã·ã‚ˆã®Xåº§æ¨™
            const nextCy = y + nextDy; // æ–°ã—ã„å¯å‹•ã·ã‚ˆã®Yåº§æ¨™
            
            // 1. æ–°ã—ã„å¯å‹•ã·ã‚ˆã®ä½ç½®ãŒå£ã‚„ä»–ã®ã·ã‚ˆã¨è¡çªã™ã‚‹ã‹ãƒã‚§ãƒƒã‚¯
            if (nextCx < 0 || nextCx >= Config.cols || (nextCy >= 0 && this.stage.board[nextCy]?.[nextCx])) {
                
                // 2. è¡çªã—ãŸå ´åˆã€å£è¹´ã‚Š (Wall Kick) ã‚’è©¦ã¿ã‚‹
                let kickDirection = 0;
                // å³ç«¯ã§ä¸Š/ä¸‹å›è»¢ã‚’ã™ã‚‹ã¨ãã«å·¦ã«è¹´ã‚‹
                if ((currentRot === 90 || currentRot === 270) && x === Config.cols - 1) { 
                    kickDirection = -1;
                }
                // å·¦ç«¯ã§ä¸Š/ä¸‹å›è»¢ã‚’ã™ã‚‹ã¨ãã«å³ã«è¹´ã‚‹
                else if ((currentRot === 90 || currentRot === 270) && x === 0) {
                    kickDirection = 1;
                }
                // ãã®ä»–ï¼ˆåŸºæœ¬çš„ã«ã¯å·¦å³ã«å£ãŒã‚ã‚‹ã¨ãã«ã€æ¨ªã«è¹´ã‚‹ï¼‰
                else if (nextDx === -1) { // å·¦ã«å›è»¢ã™ã‚‹ã¨ãï¼ˆä¾‹: 0åº¦ -> 270åº¦ï¼‰
                    kickDirection = 1;
                } else if (nextDx === 1) { // å³ã«å›è»¢ã™ã‚‹ã¨ãï¼ˆä¾‹: 180åº¦ -> 90åº¦ï¼‰
                    kickDirection = -1;
                }
                
                if (kickDirection !== 0 && this.canMove(kickDirection)) {
                    newX = x + kickDirection; // è¹´ã‚Šå¾Œã®æ–°ã—ã„Xåº§æ¨™
                } else {
                    canRotate = false; // è¹´ã‚Šã‚‚å¤±æ•—
                }
            }
            
            const finalMx = newX + nextDx;
            const finalMy = y + nextDy;
            
            // 3. è¹´ã‚Šå¾Œã®æ–°ã—ã„ä½ç½®ã§ã€å†åº¦å¯å‹•ã·ã‚ˆã®ä½ç½®ã‚’ãƒã‚§ãƒƒã‚¯
            if (canRotate && (finalMx < 0 || finalMx >= Config.cols || (finalMy >= 0 && this.stage.board[finalMy]?.[finalMx]))) {
                 canRotate = false;
            }
            
            if (canRotate) {
                this.puyoStatus.x = newX;
                this.puyoStatus.rotation = nextRot;
                this.puyoStatus.dx = nextDx;
                this.puyoStatus.dy = nextDy;
                
                // å›è»¢ã«ã‚ˆã‚ŠåºŠã‹ã‚‰é›¢ã‚ŒãŸå ´åˆã¯æ¥åœ°ãƒ•ãƒ¬ãƒ¼ãƒ ã‚’ãƒªã‚»ãƒƒãƒˆ
                if (y + 1 < Config.rows && !this.stage.board[y + 1]?.[newX] && (y + nextDy + 1 < Config.rows && !this.stage.board[y + nextDy + 1]?.[newX + nextDx])) {
                    this.groundFrame = 0;
                }
            }
            
            this.keyStatus.rotate = false;
        }
        
        this.setPuyoPosition();
        return 'playing';
    }
    
    fix() {
        const x = Math.round(this.puyoStatus.x);
        const y = Math.floor(this.puyoStatus.y);
        const dx = this.puyoStatus.dx;
        const dy = this.puyoStatus.dy;
        
        if (y >= 0) {
            this.stage.setPuyo(x, y, this.centerPuyo);
            this.stage.puyoCount++;
        }
        if (y + dy >= 0) {
            this.stage.setPuyo(x + dx, y + dy, this.movablePuyo);
            this.stage.puyoCount++;
        }
        
        this.stage.element.removeChild(this.centerElement);
        this.stage.element.removeChild(this.movableElement);
        this.centerElement = null;
        this.movableElement = null;
    }
}

class Game {
    constructor() {
        this.stage = new Stage(); 
        
        this.stage.setSize(50); 
        this.calculatePuyoSize(); 
        this.stage.setSize(Config.puyoSize); 
        
        this.player = new Player(this.stage);
        this.mode = 'start';
        this.frame = 0;
        this.score = 0;
        this.combinationCount = 0;
        this.scoreElement = document.getElementById('score-value');
        this.comboDisplayElement = document.getElementById('combo-display');
        this.comboDisplayFrame = 0;
        
        this.nextCenterPuyo = this.getRandomPuyoType();
        this.nextMovablePuyo = this.getRandomPuyoType();
        this.nextPuyoContainer = document.getElementById('next-puyo-container');
        
        this.drawNextPuyo();
        
        // ãƒªã‚µã‚¤ã‚ºã‚¤ãƒ™ãƒ³ãƒˆã‚’è¿½åŠ ã—ã¦ã€ç”»é¢å›è»¢æ™‚ã«ã‚µã‚¤ã‚ºã‚’å†è¨ˆç®—
        window.addEventListener('resize', () => {
             this.resizeGame();
        });
    }

    resizeGame() {
        this.calculatePuyoSize();
        this.stage.setSize(Config.puyoSize);
        this.drawNextPuyo();
        // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã·ã‚ˆã®ä½ç½®ã‚‚æ›´æ–°ã—ãŸã„ãŒã€ã‚²ãƒ¼ãƒ é€²è¡Œä¸­ãªã®ã§ãƒªã‚µã‚¤ã‚ºæ™‚ã¯å›ºå®šã·ã‚ˆã®ã¿
    }
    
    calculatePuyoSize() {
        const stageElement = document.getElementById('stage');
        const mainContentElement = document.getElementById('main-content');
        
        // FlexboxãŒæ—¢ã«é«˜ã•ã‚’ç¢ºä¿ã—ã¦ã„ã‚‹ãŸã‚ã€clientWidth/clientHeightã‚’ä½¿ç”¨
        
        // 1. æ¨ªå¹…ã‹ã‚‰ã·ã‚ˆã‚µã‚¤ã‚ºã‚’è¨ˆç®— (ã‚¹ãƒ†ãƒ¼ã‚¸6ãƒã‚¹ + NEXTã‚¨ãƒªã‚¢ç´„2.5ãƒã‚¹)
        const horizontalPuyoArea = Config.cols + 2.5; 
        const widthPuyoSize = Math.floor(mainContentElement.clientWidth / horizontalPuyoArea); 

        // 2. é«˜ã•ã‹ã‚‰ã·ã‚ˆã‚µã‚¤ã‚ºã‚’è¨ˆç®— (ã‚¹ãƒ†ãƒ¼ã‚¸12è¡Œ)
        const heightPuyoSize = Math.floor(stageElement.clientHeight / Config.rows); 

        // 3. æœ€çµ‚çš„ãªã‚µã‚¤ã‚ºã‚’æ±ºå®š (æœ€å°30pxã€æœ€å¤§60pxã«åˆ¶é™)
        Config.puyoSize = Math.max(30, Math.min(widthPuyoSize, heightPuyoSize, 60)); 
    }

    getRandomPuyoType() {
        return AED_TYPES[Math.floor(Math.random() * AED_TYPES.length)];
    }

    drawNextPuyo() {
        this.nextPuyoContainer.innerHTML = '';
        const size = Config.puyoSize;
        const container = this.nextPuyoContainer;

        const centerCanvas = document.createElement('canvas');
        centerCanvas.width = size;
        centerCanvas.height = size;
        centerCanvas.style.position = 'absolute';
        centerCanvas.style.left = '0px'; 
        centerCanvas.style.top = '0px'; 
        const ctxC = centerCanvas.getContext('2d');
        drawAED(ctxC, this.nextCenterPuyo, size);
        container.appendChild(centerCanvas);

        const movableCanvas = document.createElement('canvas');
        movableCanvas.width = size;
        movableCanvas.height = size;
        movableCanvas.style.position = 'absolute';
        movableCanvas.style.left = '0px';
        movableCanvas.style.top = size + 'px'; 
        const ctxM = movableCanvas.getContext('2d');
        drawAED(ctxM, this.nextMovablePuyo, size);
        container.appendChild(movableCanvas);
        
        container.style.width = size + 'px';
        container.style.height = (size * 2) + 'px'; 
    }
    
    addScore(points) {
        this.score += points;
        this.scoreElement.textContent = this.score;
    }
    
    updateComboDisplay() {
        const size = Config.puyoSize;
        this.comboDisplayElement.style.width = size * Config.cols + 'px';
        this.comboDisplayElement.style.height = size * Config.rows + 'px';
        this.comboDisplayElement.style.fontSize = `${Math.min(size * 0.8, 40)}px`;
        
        if (this.comboDisplayFrame > 0) {
            this.comboDisplayFrame--;
            if (this.combinationCount > 0) {
                 this.comboDisplayElement.style.opacity = '1';
                 this.comboDisplayElement.textContent = `${this.combinationCount} é€£é–ï¼`;
            }
        } else {
            this.comboDisplayElement.style.opacity = '0';
        }
    }
    
    loop() {
        this.updateComboDisplay();
        
        switch (this.mode) {
            case 'start':
                break;
            
            case 'checkFall':
                if (this.stage.checkFall()) {
                    this.mode = 'fall';
                } else {
                    this.mode = 'checkErase';
                }
                break;
                
            case 'fall':
                if (!this.stage.fall()) {
                    this.mode = 'checkErase';
                }
                break;
                
            case 'checkErase':
                const eraseInfo = this.stage.checkErase(this.frame);
                if (eraseInfo) {
                    this.mode = 'erasing';
                    this.combinationCount++;
                    const points = eraseInfo.piece * 10 * Math.pow(2, this.combinationCount - 1);
                    this.addScore(points);
                    
                    this.comboDisplayFrame = Config.comboDisplayDuration;
                } else {
                    this.combinationCount = 0;
                    this.mode = 'newPuyo';
                }
                break;
                
            case 'erasing':
                if (!this.stage.erasing(this.frame)) {
                    this.mode = 'checkFall';
                }
                break;
                
            case 'newPuyo':
                const currentPuyoType = { 
                    center: this.nextCenterPuyo,
                    movable: this.nextMovablePuyo
                };

                if (!this.player.createNewPuyo(currentPuyoType)) {
                    this.mode = 'gameOver';
                } else {
                    this.nextCenterPuyo = this.getRandomPuyoType();
                    this.nextMovablePuyo = this.getRandomPuyoType();
                    this.drawNextPuyo();
                    this.mode = 'playing';
                }
                break;
                
            case 'playing':
                this.mode = this.player.playing();
                break;
                
            case 'fix':
                this.player.fix();
                this.mode = 'checkFall';
                break;
                
            case 'gameOver':
                alert(`ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼ï¼\nã‚¹ã‚³ã‚¢: ${this.score}`);
                location.reload();
                return;
        }
        
        this.frame++;
        requestAnimationFrame(() => this.loop());
    }
    
    start() {
        document.getElementById('start-screen').style.display = 'none';
        this.setupTouchControls();
        this.mode = 'checkFall';
        this.loop();
    }

    setupTouchControls() {
        const stageElement = this.stage.element;
        let startX = 0;
        let startY = 0;
        let moved = false;
        let isDownSliding = false;

        stageElement.addEventListener('touchstart', e => {
            if (e.touches.length === 1) {
                startX = e.touches[0].clientX;
                startY = e.touches[0].clientY;
                moved = false;
                isDownSliding = false;
                this.player.setTouchAction('release_down');
                this.player.setTouchAction('release_horizontal');
                this.player.moveFrame = 0;
            }
        });

        stageElement.addEventListener('touchmove', e => {
            if (e.touches.length === 1) {
                const deltaX = e.touches[0].clientX - startX;
                const deltaY = e.touches[0].clientY - startY;

                if (Math.abs(deltaX) > 10 || Math.abs(deltaY) > 10) {
                    moved = true;
                }

                if (Math.abs(deltaX) > Config.touchThreshold && Math.abs(deltaX) > Math.abs(deltaY)) {
                    if (deltaX > 0) {
                        this.player.setTouchAction('right');
                    } else {
                        this.player.setTouchAction('left');
                    }
                    // ã‚¹ãƒ©ã‚¤ãƒ‰æ“ä½œã§ã¯ã€1å›ã®ã‚¹ãƒ©ã‚¤ãƒ‰ã§1ãƒã‚¹ç§»å‹•ã•ã›ã‚‹ãŸã‚ã€ã‚­ãƒ¼çŠ¶æ…‹ã‚’ã™ãã«è§£é™¤ã™ã‚‹
                    setTimeout(() => this.player.setTouchAction('release_horizontal'), 50); 
                    startX = e.touches[0].clientX; // æ–°ã—ã„Xåº§æ¨™ã‚’è¨˜éŒ²
                }
                
                if (deltaY > Config.touchThreshold && Math.abs(deltaY) > Math.abs(deltaX)) {
                    this.player.setTouchAction('down');
                    isDownSliding = true;
                } else if (isDownSliding && deltaY < 0) { // ä¸Šæ–¹å‘ã¸ã®ã‚¹ãƒ©ã‚¤ãƒ‰ã¯é«˜é€Ÿè½ä¸‹ã‚’è§£é™¤
                    this.player.setTouchAction('release_down');
                    isDownSliding = false;
                }
            }
            if (e.cancelable) {
                e.preventDefault();
            }
        });

        stageElement.addEventListener('touchend', e => {
            this.player.setTouchAction('release_down');
            this.player.setTouchAction('release_horizontal');
            
            if (!moved) { 
                 this.player.setTouchAction('rotate');
            }
        });
    }
}

window.addEventListener('load', () => {
    const game = new Game();
    
    document.getElementById('start-button').addEventListener('click', () => {
        game.start();
    });
});
</script>
</body>
</html>